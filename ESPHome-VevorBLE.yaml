# ============================================
# Chauffage Diesel VEVOR BLE - Configuration ESPHome
# ============================================
# 
# IMPORTANT : À ajuster avant utilisation !
# 1. Remplace l'adresse MAC par celle de ton chauffage
# 2. Change le nom de l'appareil si souhaité
# 3. Crée un fichier secrets.yaml avec tes identifiants WiFi
# ============================================

substitutions:
  # IMPORTANT : Entre l'adresse MAC BLE de ton chauffage ici !
  heater_mac: "XX:XX:XX:XX:XX:XX"  # <-- À MODIFIER !
  
  name: bt-vevor-ble
  friendly_name: Chauffage Diesel
  
  # UUIDs du service BLE
  service_uuid: "0000fff0-0000-1000-8000-00805f9b34fb"
  char_fff1_uuid: "0000fff1-0000-1000-8000-00805f9b34fb"
  char_fff2_uuid: "0000fff2-0000-1000-8000-00805f9b34fb"

esphome:
  name: ${name}
  name_add_mac_suffix: true
  friendly_name: ${friendly_name}
  min_version: 2025.9.3
  project:
    name: vevor.ble_heater
    version: "1.0"

dashboard_import:
  package_import_url: github://esphome/example-configs/esphome-web/esp32.yaml@main
  import_full_config: false

packages:
  esphome_web: github://esphome/example-configs/esphome-web/esp32.yaml@main

esp32_improv:
  authorizer: none

web_server:
  port: 80
  version: 3
  local: true

captive_portal:

esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: DEBUG

# API Encryption Key wird automatisch generiert beim ersten Kompilieren
api:

ota:
  - platform: esphome
  - platform: web_server

# WiFi Credentials in secrets.yaml speichern!
# Erstelle eine secrets.yaml Datei mit:
# wifi_ssid: "DeinWiFiName"
# wifi_password: "DeinWiFiPasswort"
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Vevor Heater Fallback"
    password: "12345678"

globals:
  - id: ble_connecte
    type: bool
    initial_value: 'false'
  - id: mode_actuel
    type: int
    initial_value: '1'
  - id: commande_active
    type: bool
    initial_value: 'false'
  - id: temps_derniere_commande
    type: unsigned long
    initial_value: '0'

script:
  - id: send_command_safe
    parameters:
      cmd: int
    then:
      - lambda: 'id(commande_active) = true;'
      - delay: 100ms
      - ble_client.ble_write:
          id: chauffage_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: !lambda |-
            uint8_t checksum = 0xBA + 0xAB + 0x04 + 0xBB + cmd;
            return {0xBA, 0xAB, 0x04, 0xBB, (uint8_t)cmd, 0x00, 0x00, checksum};
      - delay: 500ms
      - ble_client.ble_write:
          id: chauffage_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]
      - delay: 500ms
      - lambda: |-
          id(commande_active) = false;
          id(temps_derniere_commande) = millis();

interval:
  - interval: 5s
    then:
      - if:
          condition:
            lambda: |-
              return id(ble_connecte) && 
                     !id(commande_active) && 
                     (millis() - id(temps_derniere_commande) > 2000);
          then:
            - ble_client.ble_write:
                id: chauffage_ble
                service_uuid: ${service_uuid}
                characteristic_uuid: ${char_fff2_uuid}
                value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]

ble_client:
  - mac_address: ${heater_mac}
    id: chauffage_ble
    on_connect:
      - lambda: 'id(ble_connecte) = true;'
      - logger.log: "BLE Connecté"
      - delay: 2s
      - ble_client.ble_write:
          id: chauffage_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]
          
    on_disconnect:
      - lambda: 'id(ble_connecte) = false;'
      - logger.log: "BLE Déconnecté"

text_sensor:
  - platform: template
    name: "Mode de fonctionnement"
    id: mode_fonctionnement_text

  - platform: template
    name: "Statut du chauffage"
    id: statut_chauffage_text

binary_sensor:
  - platform: template
    name: "État Chauffage"
    id: chauffage_actif_sensor

sensor:
  - platform: template
    name: "Valeur cible"
    id: valeur_cible
    accuracy_decimals: 0

  - platform: template
    name: "Température ambiante"
    id: temperature_ambiante
    unit_of_measurement: "°C"
    accuracy_decimals: 1

  - platform: template
    name: "Tension batterie"
    id: tension_batterie
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: voltage

  - platform: template
    name: "Température corps"
    id: temperature_corps
    unit_of_measurement: "°C"
    accuracy_decimals: 0

  - platform: ble_client
    type: characteristic
    id: ble_reponse
    ble_client_id: chauffage_ble
    service_uuid: ${service_uuid}
    characteristic_uuid: ${char_fff1_uuid}
    name: "Données brutes BLE"
    notify: true
    lambda: |-
      if (x.size() >= 21 && x[0] == 0xAB && x[1] == 0xBA) {
        uint8_t courant = x[4];
        uint8_t mode_flag = x[5];
        uint8_t cible = x[6];
        uint8_t etat_fonct = x[7];
        uint8_t tension = x[9];
        float temp_amb = x[11] / 2.2;
        uint8_t temp_corps = x[13];
        
        const char* noms_etats[] = {"Prêt", "Préchauffage", "Auto-test", "Allumage", "Chauffage", "Arrêt en cours"};
        const char* statut_courant = (courant == 0x00) ? "ÉTEINT" : (courant == 0x01) ? "ALLUMÉ" : "Refroidissement";
        
        ESP_LOGW("BLE", "État: %s | Mode: %s | Cible: %d", statut_courant, mode_flag ? "Automatique" : "Manuel", cible);
        
        id(chauffage_actif_sensor).publish_state(courant == 0x01);
        id(interrupteur_chauffage).publish_state(courant == 0x01);
        id(mode_actuel) = mode_flag;
        id(valeur_cible).publish_state(cible);
        id(temperature_ambiante).publish_state(temp_amb);
        id(tension_batterie).publish_state(tension);
        id(temperature_corps).publish_state(temp_corps);
        id(mode_fonctionnement_text).publish_state(mode_flag ? "Automatique" : "Manuel");
        
        std::string texte_complet = statut_courant;
        if (courant == 0x01 && etat_fonct < 6) {
          texte_complet = texte_complet + " - " + noms_etats[etat_fonct];
        }
        id(statut_chauffage_text).publish_state(texte_complet);
      }
      return x.size();

switch:
  - platform: template
    name: "Chauffage On/Off"
    id: interrupteur_chauffage
    icon: "mdi:fire"
    optimistic: true
    turn_on_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA1
    turn_off_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA1

  - platform: template
    name: "Ventilateur"
    id: mode_ventilateur
    icon: "mdi:fan"
    optimistic: true
    turn_on_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA4
    turn_off_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA4

button:
  - platform: template
    name: "Changer de Mode"
    icon: "mdi:swap-horizontal"
    on_press:
      - script.execute:
          id: send_command_safe
          cmd: 0xAD

  - platform: template
    name: "Température +"
    icon: "mdi:thermometer-plus"
    on_press:
      - if:
          condition:
            lambda: 'return id(mode_actuel) == 1;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA2

  - platform: template
    name: "Puissance +"
    icon: "mdi:fan-plus"
    on_press:
      - if:
          condition:
            lambda: 'return id(mode_actuel) == 0;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA2

number:
  - platform: template
    name: "Température Cible"
    id: slider_temperature
    min_value: 8
    max_value: 36
    step: 1
    unit_of_measurement: "°C"
    mode: slider
    optimistic: false
    lambda: 'return (id(mode_actuel) == 1) ? id(valeur_cible).state : (float)NAN;'
    set_action:
      - if:
          condition:
            lambda: 'return id(mode_actuel) == 1 && (int)x != (int)id(valeur_cible).state;'
          then:
            - lambda: 'id(commande_active) = true;'
            - repeat:
                count: !lambda 'return abs((int)x - (int)id(valeur_cible).state);'
                then:
                  - ble_client.ble_write:
                      id: chauffage_ble
                      service_uuid: ${service_uuid}
                      characteristic_uuid: ${char_fff2_uuid}
                      value: !lambda 'return ((int)x > (int)id(valeur_cible).state) ? std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA2, 0x00, 0x00, 0xC6} : std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA3, 0x00, 0x00, 0xC7};'
                  - delay: 600ms
            - delay: 500ms
            - lambda: |-
                id(commande_active) = false;
                id(temps_derniere_commande) = millis();
