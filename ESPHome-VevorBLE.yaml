# ============================================
# VEVOR BLE Diesel Heater - ESPHome Configuration
# ============================================
# 
# WICHTIG: Vor der Nutzung anpassen!
# 1. Ersetze die MAC-Adresse mit deiner Heizungs-MAC
# 2. Ändere den Gerätenamen wenn gewünscht
# 3. Erstelle eine secrets.yaml mit WiFi-Daten
#
# MAC-Adresse deiner Heizung findest du mit:
# - BLE Scanner App (z.B. "nRF Connect")
# - ESPHome BLE Tracker Log
# ============================================

substitutions:
  # WICHTIG: Hier deine BLE Heizungs-MAC-Adresse eintragen!
  heater_mac: "XX:XX:XX:XX:XX:XX"  # <-- ANPASSEN!
  
  # Optional: Gerätenamen anpassen
  name: bt-vevor-ble
  friendly_name: Diesel Standheizung
  
  # BLE Service UUIDs (normalerweise identisch für alle VEVOR Heizungen)
  service_uuid: "0000fff0-0000-1000-8000-00805f9b34fb"
  char_fff1_uuid: "0000fff1-0000-1000-8000-00805f9b34fb"
  char_fff2_uuid: "0000fff2-0000-1000-8000-00805f9b34fb"

esphome:
  name: ${name}
  name_add_mac_suffix: true  # Fügt automatisch MAC-Suffix hinzu für Eindeutigkeit
  friendly_name: ${friendly_name}
  min_version: 2025.9.3
  project:
    name: vevor.ble_heater
    version: "1.0"

dashboard_import:
  package_import_url: github://esphome/example-configs/esphome-web/esp32.yaml@main
  import_full_config: false

packages:
  esphome_web: github://esphome/example-configs/esphome-web/esp32.yaml@main

esp32_improv:
  authorizer: none

web_server:
  port: 80
  version: 3
  local: true

captive_portal:

esp32_ble_tracker:
  scan_parameters:
    interval: 1100ms
    window: 1100ms
    active: true

esp32:
  board: esp32dev
  framework:
    type: esp-idf

logger:
  level: DEBUG

# API Encryption Key wird automatisch generiert beim ersten Kompilieren
api:

ota:
  - platform: esphome
  - platform: web_server

# WiFi Credentials in secrets.yaml speichern!
# Erstelle eine secrets.yaml Datei mit:
# wifi_ssid: "DeinWiFiName"
# wifi_password: "DeinWiFiPasswort"
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Vevor Heater Fallback"
    password: "12345678"

globals:
  - id: ble_verbunden
    type: bool
    initial_value: 'false'
  - id: aktueller_modus
    type: int
    initial_value: '1'
  - id: command_aktiv
    type: bool
    initial_value: 'false'
  - id: letzter_befehl_zeit
    type: unsigned long
    initial_value: '0'

script:
  - id: send_command_safe
    parameters:
      cmd: int
    then:
      - lambda: 'id(command_aktiv) = true;'
      - delay: 100ms
      - ble_client.ble_write:
          id: heizung_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: !lambda |-
            uint8_t checksum = 0xBA + 0xAB + 0x04 + 0xBB + cmd;
            return {0xBA, 0xAB, 0x04, 0xBB, (uint8_t)cmd, 0x00, 0x00, checksum};
      - delay: 500ms
      - ble_client.ble_write:
          id: heizung_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]
      - delay: 500ms
      - lambda: |-
          id(command_aktiv) = false;
          id(letzter_befehl_zeit) = millis();

interval:
  - interval: 5s
    then:
      - if:
          condition:
            lambda: |-
              return id(ble_verbunden) && 
                     !id(command_aktiv) && 
                     (millis() - id(letzter_befehl_zeit) > 2000);
          then:
            - ble_client.ble_write:
                id: heizung_ble
                service_uuid: ${service_uuid}
                characteristic_uuid: ${char_fff2_uuid}
                value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]

ble_client:
  - mac_address: ${heater_mac}
    id: heizung_ble
    on_connect:
      - lambda: 'id(ble_verbunden) = true;'
      - logger.log: "BLE Verbunden"
      - delay: 2s
      - ble_client.ble_write:
          id: heizung_ble
          service_uuid: ${service_uuid}
          characteristic_uuid: ${char_fff2_uuid}
          value: [0xBA, 0xAB, 0x04, 0xCC, 0x00, 0x00, 0x00, 0x35]
          
    on_disconnect:
      - lambda: 'id(ble_verbunden) = false;'
      - logger.log: "BLE Getrennt"

text_sensor:
  - platform: template
    name: "Betriebsmodus"
    id: betriebsmodus_text

  - platform: template
    name: "Heizungsstatus"
    id: heizung_status_text

binary_sensor:
  - platform: template
    name: "Heizung Status"
    id: heizung_an_sensor

sensor:
  - platform: template
    name: "Zielwert"
    id: zielwert
    accuracy_decimals: 0

  - platform: template
    name: "Raumtemperatur"
    id: raumtemperatur
    unit_of_measurement: "°C"
    accuracy_decimals: 1

  - platform: template
    name: "Batteriespannung"
    id: batteriespannung
    unit_of_measurement: "V"
    accuracy_decimals: 1
    device_class: voltage

  - platform: template
    name: "Schalentemperatur"
    id: schalentemperatur
    unit_of_measurement: "°C"
    accuracy_decimals: 0

  - platform: ble_client
    type: characteristic
    id: ble_antwort
    ble_client_id: heizung_ble
    service_uuid: ${service_uuid}
    characteristic_uuid: ${char_fff1_uuid}
    name: "BLE Rohdaten"
    notify: true
    lambda: |-
      if (x.size() >= 21 && x[0] == 0xAB && x[1] == 0xBA) {
        uint8_t strom = x[4];
        uint8_t modus_flag = x[5];
        uint8_t ziel = x[6];
        uint8_t betrieb_zustand = x[7];
        uint8_t spannung = x[9];
        float raumtemp = x[11] / 2.2;
        uint8_t schalentemp = x[13];
        
        const char* zustand_namen[] = {"Bereit", "Aufwärmen", "Selbsttest", "Zündung", "Heizen", "Herunterfahren"};
        const char* strom_status = (strom == 0x00) ? "AUS" : (strom == 0x01) ? "EIN" : "Kühlphase";
        
        ESP_LOGW("BLE", "Strom: %s | Modus: %s | Ziel: %d", strom_status, modus_flag ? "Automatik" : "Manuell", ziel);
        
        id(heizung_an_sensor).publish_state(strom == 0x01);
        id(heizung_schalter).publish_state(strom == 0x01);
        id(aktueller_modus) = modus_flag;
        id(zielwert).publish_state(ziel);
        id(raumtemperatur).publish_state(raumtemp);
        id(batteriespannung).publish_state(spannung);
        id(schalentemperatur).publish_state(schalentemp);
        id(betriebsmodus_text).publish_state(modus_flag ? "Automatik" : "Manuell");
        
        std::string status_text = strom_status;
        if (strom == 0x01 && betrieb_zustand < 6) {
          status_text = status_text + " - " + zustand_namen[betrieb_zustand];
        }
        id(heizung_status_text).publish_state(status_text);
      }
      return x.size();

switch:
  - platform: template
    name: "Heizung Ein/Aus"
    id: heizung_schalter
    icon: "mdi:fire"
    optimistic: true
    turn_on_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA1
    turn_off_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA1

  - platform: template
    name: "Lüfter"
    id: luefter_modus
    icon: "mdi:fan"
    optimistic: true
    turn_on_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA4
    turn_off_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA4

  - platform: template
    name: "Höhenmodus"
    id: hoehenmodus
    icon: "mdi:mountain"
    optimistic: true
    turn_on_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA5
    turn_off_action:
      - script.execute:
          id: send_command_safe
          cmd: 0xA5

button:
  - platform: template
    name: "Modus Wechseln"
    icon: "mdi:swap-horizontal"
    on_press:
      - script.execute:
          id: send_command_safe
          cmd: 0xAD

  - platform: template
    name: "Temperatur +"
    icon: "mdi:thermometer-plus"
    on_press:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 1;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA2

  - platform: template
    name: "Temperatur -"
    icon: "mdi:thermometer-minus"
    on_press:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 1;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA3

  - platform: template
    name: "Gebläse +"
    icon: "mdi:fan-plus"
    on_press:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 0;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA2

  - platform: template
    name: "Gebläse -"
    icon: "mdi:fan-minus"
    on_press:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 0;'
          then:
            - script.execute:
                id: send_command_safe
                cmd: 0xA3

number:
  - platform: template
    name: "Zieltemperatur"
    id: temperatur_slider
    min_value: 8
    max_value: 36
    step: 1
    unit_of_measurement: "°C"
    mode: slider
    optimistic: false
    lambda: 'return (id(aktueller_modus) == 1) ? id(zielwert).state : (float)NAN;'
    set_action:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 1 && (int)x != (int)id(zielwert).state;'
          then:
            - lambda: 'id(command_aktiv) = true;'
            - repeat:
                count: !lambda 'return abs((int)x - (int)id(zielwert).state);'
                then:
                  - ble_client.ble_write:
                      id: heizung_ble
                      service_uuid: ${service_uuid}
                      characteristic_uuid: ${char_fff2_uuid}
                      value: !lambda 'return ((int)x > (int)id(zielwert).state) ? std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA2, 0x00, 0x00, 0xC6} : std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA3, 0x00, 0x00, 0xC7};'
                  - delay: 600ms
            - delay: 500ms
            - lambda: |-
                id(command_aktiv) = false;
                id(letzter_befehl_zeit) = millis();

  - platform: template
    name: "Gebläsestufe"
    id: level_slider
    min_value: 1
    max_value: 6
    step: 1
    mode: slider
    optimistic: false
    lambda: 'return (id(aktueller_modus) == 0) ? id(zielwert).state : (float)NAN;'
    set_action:
      - if:
          condition:
            lambda: 'return id(aktueller_modus) == 0 && (int)x != (int)id(zielwert).state;'
          then:
            - lambda: 'id(command_aktiv) = true;'
            - repeat:
                count: !lambda 'return abs((int)x - (int)id(zielwert).state);'
                then:
                  - ble_client.ble_write:
                      id: heizung_ble
                      service_uuid: ${service_uuid}
                      characteristic_uuid: ${char_fff2_uuid}
                      value: !lambda 'return ((int)x > (int)id(zielwert).state) ? std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA2, 0x00, 0x00, 0xC6} : std::vector<uint8_t>{0xBA, 0xAB, 0x04, 0xBB, 0xA3, 0x00, 0x00, 0xC7};'
                  - delay: 600ms
            - delay: 500ms
            - lambda: |-
                id(command_aktiv) = false;
                id(letzter_befehl_zeit) = millis();
